####
函数
####

函数, 是程序中一组指令的集合, 是程序功能的一个次级模块.
虽然程序的所有逻辑都可以写在一个函数(或脚本)之中,
但是为了便于修改与扩展,
将程序尽量的模块化,
将关系最紧密的代码布置到一个函数中,
能明显地简化代码.

.. note:: 函数模块化

函数
====

在 Python 中, 可以如此定义一个函数::

    def function(param_1, param_2):

        # do something

        return result

在 :keyword:`def` 一行, 是为函数的函数头,
在这里, 定义了函数的命名与形式参数列表.
之下的 ``# do something`` 与 :keyword:`return` 语句
是函数的函数体.
函数体比函数头多一级缩进,
当缩进结束时, 表示这个函数结束.

函数命名与变量命名遵守相同的规则.
函数定义对参数的数目没有要求, 可以无参数,
也可以支持多个参数, 甚至 `无限参数`_ .

一个函数可以如此调用::

    result = function(arg1, arg2)

按照参数列表的要求, 将需要的参数传入, 经过函数的计算, 得到返回的结果.

关于函数的传参, 可以分 `定义时`_ 和 `调用时`_ 两个阶段来讨论.

定义时
------

默认参数
~~~~~~~~

在定义函数时, 对参数使用赋值语句,
将设置一个默认参数::

>>> def hello(name="Zombie110year")
>>>     print("Hello {}".format(name))

在默认参数被定义时, 调用该函数而不传入此参数,
则将该参数设置为默认值继续运行:

>>> hello()
Hello Zombie110year

而如果传入了参数, 那么则将参数的值设定为传入值.

>>> hello("NIHAO")
Hello NIHAO

.. _无限参数:

集合参数
~~~~~~~~

在定义时使用这样的语法::

>>> def log(*args, **kwargs):
>>>     print(type(args), type(kwargs))

在参数名前添加一个或两个星号,
则这两个参数将作为 :class:`tuple` 或 :class:`dict`
将调用时传入的参数或 `命名参数`_ 存储起来.

一个星号的 args(当然可以取其他命名) 存储直接传值的参数,
两个星号的 kwargs 存储以命名方式传入的参数.

可以用集合参数来承载无限个参数,
并只取用想用的部分.

参数的顺序
~~~~~~~~~~

定义函数时,
形参表中的形式参数需要遵守以下规律:

    普通参数在默认参数之前, 一般参数在集合参数之前.

例如::

    def function(a, b=1, *c, **d):
        pass

调用时
------

位置参数
~~~~~~~~

位置参数, 就是按照顺序直接传值,
会按照定义时的顺序将值赋给对应参数::

    def func(a, b, c):
        pass

    func(1, 2, 3)

    # a = 1, b = 2, c = 3

命名参数
~~~~~~~~

命名参数可以按照形参的命名将值传递给对应形参::

    func(b=1, c=2, a=3)

不过, 命名参数必须在位置参数之后,
并且不能将值传递给已接受位置参数的形参.

解包
~~~~

对于集合变量, 例如列表和元祖, 可以在传参时添加一个星号, 将其解包::

    args = (1, 2, 3)
    func(*args)

    # 等价于 func(1, 2, 3)

对于字典, 可以用两个星号解包::

    kwargs = {"a": 1, "b": 2, "c": 3}
    func(**kwargs)

    # 等价于 func(a=1, b=2, c=3)

传参顺序
~~~~~~~~

位置参数在命名参数之前, 一般参数在解包参数之前::

    func(1, *args, z=1, **kwargs)

函数的返回值
============

一个函数在遇到 :keyword:`return` 语句时, 会终止运行,
并将 return 的变量返回.

在 Python 中, 可以返回一个元祖::

    return 1, 2, 3

可以在调用时使用同等数量的变量来接收,
也可以同样使用星号来解包::

    a = func()
    # a = (1, 2, 3)

    a, b, c = func()
    # a = 1, b = 2, c = 3

    a, *b = func()
    # a = 1, b = [2, 3]

生成器
======

生成器就是将一个函数的 :keyword:`return` 语句替换成 :keyword:`yield`.

一个生成器将会保留上次调用的状态,
所以生成器的函数体一般都处于循环之内,
比如一个自然数生成器::

    def number():
        x = 0
        while True:
            yield x
            x += 1

在调用时, 需要先获得一个生成器实例::

    gen_num = number()

然后, 可以使用 :keyword:`for` 或 :class:`list` 或 :func:`next` 来获取返回值::

    x = next(gen_num)

生成器也可以设置参数::

    def number(start=0, step=1):
        x = start
        while True:
            yield x
            x += step

    gen_odd = number(0, 2)

    odd = next(gen_odd)
