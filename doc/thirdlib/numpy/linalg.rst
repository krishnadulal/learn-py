################
Numpy 与线性代数
################

线性代数中的实体:

1.  矩阵
#.  列向量 / 行向量
#.  矩阵加法
#.  矩阵乘法
#.  矩阵转置
#.  行列式
#.  逆矩阵
#.  求解线性方程组
#.  矩阵的秩, 特征值, 迹 等

矩阵与向量
==========

Numpy 中使用 :class:`numpy.ndarray` 作为矩阵的基础形式.
使用如下语法初始化::

    np.array([
        [1, 2, 3],
        [4, 5, 6],
    ], dtype=np.float32)

这将创建一个 2 行 3 列的矩阵 -- Numpy 中矩阵的形状和数学中是一致的:

    .. math::

        \begin{bmatrix}
            1 & 2 & 3 \\
            4 & 5 & 6
        \end{bmatrix}

另外有一点就是, 如果初始化时就像上面这样使用了整数的字面值,
那么多维数组中的每一个元素会被初始化为 :class:`numpy.int`,
要么使用浮点数的字面值, 要么就指定 ``dtype``.

行向量::

    np.array([
        [1, 2 ,3]
    ])

.. warning:: 如果少用一个方括号, 则创建的多维数组将无法完全模拟矩阵的行为. 比如矩阵 `转置`_

列向量::

    np.array([
        [1],
        [2],
        [3],
    ])

加法
====

加法和数组加法一致. 由于 Numpy 数组的广播特性,
如果形状相同的数组相加, 可以直接通过.
形状不同的数组相加, 则小数组会被扩展至与大数组同维度.
这就和矩阵的行为并不一致了.

线性代数禁止维度不同的矩阵相加.

乘法
====

由于 Numpy 重载的乘法是适用多维数组的, 而不是矩阵.
默认的乘法会依次将各数组对应位相乘.
要进行线性代数的乘法, 需要调用 :func:`numpy.dot` 进行矩阵点乘.

下面演示一下向量的点乘:

::

    import numpy as np
    x = np.array([1, 2, 3])
    y = np.array([[4], [5], [6]])

    x * y
    array([[ 4,  8, 12],
           [ 5, 10, 15],
           [ 6, 12, 18]])

    np.dot(x, y)
    array([32])

转置
====

矩阵转置, 使用 :meth:`numpy.ndarray.transpose` 方法:

::

    x = np.array([[1, 2, 3]])

    x.transpose()
    array([[1],
           [2],
           [3]])

行列式
======

使用 :func:`np.linalg.det` 函数:

::

    z = array([
            [0, 0, 1],
            [0, 1, 0],
            [1, 0, 0]
    ])

    np.linalg.det(z)
    -1.0

逆矩阵
======

矩阵求逆用 :func:`numpy.linalg.inv` 函数::

    z = np.array([
        [0, 0, 1],
        [0, 1, 0],
        [1, 0, 0],
    ])

    np.linalg.inv(z)
    array([
        [0., 0., 1.],
        [0., 1., 0.],
        [1., 0., 0.],
    ])

    np.dot(z, z)
    array([
        [1, 0, 0],
        [0, 1, 0],
        [0, 0, 1],
    ])

求解线性方程组
==============

调用 :func:`numpy.linalg.solve` 函数, 传入系数矩阵和结果矩阵, 返回未知数矩阵.

一个没有人想用手算的案例:

.. math::

    \begin{bmatrix}
        713 & 114 & 935 & 378 & 100 & 616 & 171 & 184 \\
        432 & 256 & 869 & 661 & 336 & 150 & 868 & 513 \\
        768 &  88 & 682 &  18 & 631 & 375 & 393 & 916 \\
        168 & 945 & 872 & 251 & 438 & 501 & 374 &  37 \\
        420 & 437 & 740 & 555 & 407 & 414 & 168 & 281 \\
        760 & 947 & 712 &  74 & 517 & 255 & 230 &  79 \\
        913 & 509 & 781 &  94 & 552 &   1 &  79 & 975 \\
        847 & 960 & 975 & 591 & 881 & 223 & 779 & 240
    \end{bmatrix} \begin{bmatrix}
        710 \\ 484 \\ 228 \\ 369 \\ 169 \\ 721 \\ 967 \\ 827
    \end{bmatrix} = \begin{bmatrix}
        1692629 \\ 2306276 \\ 2264587 \\ 1695595 \\
        1645343 \\ 1746561 \\ 2084067 \\ 2767834
    \end{bmatrix}

::

    np.linalg.solve(A, a)
    array([710., 484., 228., 369., 169., 721., 967., 827.])

    A = array([
            [713, 114, 935, 378, 100, 616, 171, 184],
            [432, 256, 869, 661, 366, 150, 868, 513],
            [768,  88, 682,  18, 631, 375, 393, 916],
            [168, 945, 872, 251, 438, 501, 374,  37],
            [420, 437, 740, 555, 407, 414, 168, 281],
            [760, 947, 712,  74, 517, 255, 230,  79],
            [913, 509, 781,  94, 552,   1,  79, 975],
            [847, 960, 975, 591, 881, 223, 779, 240]])

    a =  array([
        1692629., 2306276., 2264587., 1695595.,
        1645343., 1746561., 2084067., 2767834.
    ])

    np.linalg.solve(A, a)
    array([710., 484., 228., 369., 169., 721., 967., 827.])
